# Data Model: Unit Test Suite with Continuous Runner

**Feature**: 002-unit-test-runner  
**Version**: 1.0  
**Last Updated**: 2025-11-13

## Overview

This document defines the data structures, entities, and relationships for the unit testing infrastructure. The model emphasizes **runtime test execution state** rather than persisted data, as tests are ephemeral operations.

---

## Core Entities

### 1. Test Suite

**Description**: Collection of related test cases, typically organized by feature or component.

**Attributes**:
- `name` (string, required): Suite identifier (e.g., "Navigation Component Tests")
- `filePath` (string, required): Absolute path to test file
- `testCases` (TestCase[], required): Array of test cases in this suite
- `setupHooks` (TestHook[], optional): beforeAll, beforeEach hooks
- `teardownHooks` (TestHook[], optional): afterEach, afterAll hooks
- `status` (TestSuiteStatus, computed): Overall suite status (pending | running | passed | failed | skipped)
- `duration` (number, computed): Total execution time in milliseconds
- `passedCount` (number, computed): Number of passed tests
- `failedCount` (number, computed): Number of failed tests
- `totalCount` (number, computed): Total number of test cases

**Validation Rules**:
- Must contain at least one test case (FR-001)
- File path must end with `.test.ts` or `.test.tsx` (FR-001)
- Suite name must be unique within file (Jest enforces with `describe`)
- Duration must be ≤2000ms for watch mode re-runs (SC-006)

**Example**:
```typescript
{
  name: "Navigation Component",
  filePath: "/src/components/__tests__/Navigation.test.tsx",
  testCases: [testCase1, testCase2, testCase3],
  setupHooks: [beforeEachHook],
  teardownHooks: [afterEachHook],
  status: "passed",
  duration: 247,
  passedCount: 3,
  failedCount: 0,
  totalCount: 3
}
```

---

### 2. Test Case

**Description**: Individual test that verifies a single behavior or expectation.

**Attributes**:
- `id` (string, required): Unique identifier (generated by Jest)
- `name` (string, required): Descriptive test name (e.g., "renders navigation links correctly")
- `suiteName` (string, required): Parent suite name
- `filePath` (string, required): Path to test file
- `status` (TestStatus, required): Current execution state (pending | running | passed | failed | skipped | todo)
- `duration` (number, optional): Execution time in milliseconds
- `error` (TestError, optional): Failure details if status is "failed"
- `assertions` (Assertion[], optional): List of assertions made
- `retryCount` (number, default: 0): Number of times test was retried (not used in spec, but Jest supports)

**Validation Rules**:
- Name must be descriptive (FR-001, SC-004 - tests are self-documenting)
- Must contain at least one assertion (FR-002)
- Duration must be ≤200ms for individual tests (FR-010, performance target)
- Status transitions: pending → running → (passed | failed | skipped)

**Example**:
```typescript
{
  id: "abc123",
  name: "displays correct number of navigation links",
  suiteName: "Navigation Component",
  filePath: "/src/components/__tests__/Navigation.test.tsx",
  status: "passed",
  duration: 43,
  error: null,
  assertions: [
    { type: "toBeInTheDocument", expected: 3, actual: 3, passed: true }
  ],
  retryCount: 0
}
```

---

### 3. Test Runner

**Description**: Engine that discovers, schedules, and executes test suites.

**Attributes**:
- `mode` (RunnerMode, required): Execution mode (single | watch | coverage)
- `status` (RunnerStatus, required): Current state (idle | discovering | running | completed | error)
- `totalSuites` (number, computed): Total test suites found
- `executedSuites` (number, computed): Suites run so far
- `startTime` (Date, optional): When execution started
- `endTime` (Date, optional): When execution finished
- `config` (JestConfig, required): Jest configuration object
- `watchedFiles` (string[], optional): Files being watched in watch mode
- `changedFiles` (string[], optional): Files changed since last run (watch mode)

**Validation Rules**:
- Must discover all `.test.ts` and `.test.tsx` files (FR-001)
- Must complete all suites in <10 seconds for 50 tests (SC-005)
- Watch mode must detect file changes within 2 seconds (SC-006)
- Must support keyboard interruption (FR-012)

**Example**:
```typescript
{
  mode: "watch",
  status: "running",
  totalSuites: 8,
  executedSuites: 3,
  startTime: new Date("2025-11-13T10:30:00Z"),
  endTime: null,
  config: jestConfigObject,
  watchedFiles: ["/src/components/__tests__/Navigation.test.tsx", ...],
  changedFiles: ["/src/components/Navigation.tsx"]
}
```

---

### 4. Coverage Report

**Description**: Metrics on code execution during test runs.

**Attributes**:
- `timestamp` (Date, required): When coverage was collected
- `overallCoverage` (CoverageMetrics, required): Global coverage stats
- `fileCoverage` (Map<string, FileCoverage>, required): Per-file coverage details
- `uncoveredLines` (Map<string, number[]>, required): Line numbers not executed per file
- `thresholds` (CoverageThresholds, optional): Minimum coverage requirements

**Sub-Entity: CoverageMetrics**:
- `statements` (CoveragePercent): Statement coverage (0-100)
- `branches` (CoveragePercent): Branch coverage (0-100)
- `functions` (CoveragePercent): Function coverage (0-100)
- `lines` (CoveragePercent): Line coverage (0-100)

**Sub-Entity: FileCoverage**:
- `path` (string): File path
- `metrics` (CoverageMetrics): Coverage for this file
- `uncoveredLines` (number[]): Line numbers not covered
- `partiallyExecutedBranches` (number[]): Line numbers with partial branch coverage

**Validation Rules**:
- Coverage percentages must be 0-100 (FR-007)
- Must track all 4 metrics: statements, branches, functions, lines (FR-007)
- Must identify uncovered lines (FR-008, SC-007)
- Coverage must be accurate (SC-007)

**Example**:
```typescript
{
  timestamp: new Date("2025-11-13T10:35:12Z"),
  overallCoverage: {
    statements: 87.5,
    branches: 75.0,
    functions: 90.0,
    lines: 88.2
  },
  fileCoverage: new Map([
    ["/src/components/Navigation.tsx", {
      path: "/src/components/Navigation.tsx",
      metrics: { statements: 100, branches: 100, functions: 100, lines: 100 },
      uncoveredLines: [],
      partiallyExecutedBranches: []
    }],
    ["/src/data/travels.ts", {
      path: "/src/data/travels.ts",
      metrics: { statements: 60, branches: 50, functions: 66.6, lines: 62.5 },
      uncoveredLines: [23, 24, 45],
      partiallyExecutedBranches: [30]
    }]
  ]),
  thresholds: { statements: 80, branches: 70, functions: 80, lines: 80 }
}
```

---

### 5. Mock / Stub

**Description**: Test double that replaces real dependencies with controlled implementations.

**Attributes**:
- `type` (MockType, required): Kind of mock (module | function | spy | partial)
- `target` (string, required): What is being mocked (module path or function name)
- `implementation` (Function, optional): Custom mock implementation
- `returnValue` (any, optional): Static return value
- `calls` (MockCall[], optional): History of invocations (for spies)
- `mockClear` (Function, required): Reset call history
- `mockRestore` (Function, required): Restore original implementation

**Sub-Entity: MockCall**:
- `args` (any[]): Arguments passed to mock
- `returnValue` (any): Value returned by mock
- `timestamp` (Date): When call occurred

**Validation Rules**:
- Module mocks must target valid module paths (FR-005)
- Spies must preserve original function signature (FR-005)
- Mocks must be restored after each test (FR-013 - test isolation)

**Example**:
```typescript
{
  type: "module",
  target: "next/navigation",
  implementation: () => ({ usePathname: jest.fn(() => '/') }),
  returnValue: null,
  calls: [],
  mockClear: jest.clearAllMocks,
  mockRestore: jest.restoreAllMocks
}
```

---

### 6. Assertion

**Description**: Individual expectation within a test case.

**Attributes**:
- `type` (string, required): Matcher name (e.g., "toBe", "toBeInTheDocument")
- `expected` (any, required): Expected value
- `actual` (any, required): Actual value received
- `passed` (boolean, required): Whether assertion succeeded
- `message` (string, optional): Failure message if passed is false

**Validation Rules**:
- Must have clear expected/actual values for debugging (FR-003)
- Message must explain why assertion failed (FR-003)
- Must use semantic matchers for DOM elements (FR-006 - RTL best practices)

**Example**:
```typescript
{
  type: "toHaveTextContent",
  expected: "Home",
  actual: "Home",
  passed: true,
  message: null
}
```

---

### 7. Test Hook

**Description**: Setup or teardown function that runs before/after tests.

**Attributes**:
- `type` (HookType, required): When hook runs (beforeAll | beforeEach | afterEach | afterAll)
- `name` (string, optional): Descriptive name
- `implementation` (Function, required): Hook function
- `scope` (HookScope, required): Where hook applies (suite | global)
- `timeout` (number, default: 5000): Maximum execution time in milliseconds

**Validation Rules**:
- beforeAll/afterAll run once per suite (Jest behavior)
- beforeEach/afterEach run once per test (Jest behavior)
- Hooks must not share state between tests (FR-013 - test isolation)
- Hooks must complete within timeout (FR-010 - performance)

**Example**:
```typescript
{
  type: "beforeEach",
  name: "reset test environment",
  implementation: () => { jest.clearAllMocks(); },
  scope: "suite",
  timeout: 5000
}
```

---

## Enumerations

### TestStatus
```typescript
enum TestStatus {
  PENDING = "pending",      // Not yet executed
  RUNNING = "running",      // Currently executing
  PASSED = "passed",        // All assertions succeeded
  FAILED = "failed",        // At least one assertion failed
  SKIPPED = "skipped",      // Explicitly skipped (.skip)
  TODO = "todo"             // Placeholder test (.todo)
}
```

### TestSuiteStatus
```typescript
enum TestSuiteStatus {
  PENDING = "pending",      // No tests run yet
  RUNNING = "running",      // At least one test running
  PASSED = "passed",        // All tests passed
  FAILED = "failed",        // At least one test failed
  SKIPPED = "skipped"       // All tests skipped
}
```

### RunnerMode
```typescript
enum RunnerMode {
  SINGLE = "single",        // Run once and exit (FR-009)
  WATCH = "watch",          // Continuous re-runs on file changes (FR-011)
  COVERAGE = "coverage"     // Run with coverage collection (FR-007)
}
```

### RunnerStatus
```typescript
enum RunnerStatus {
  IDLE = "idle",            // No execution in progress
  DISCOVERING = "discovering", // Finding test files
  RUNNING = "running",      // Executing tests
  COMPLETED = "completed",  // All tests finished
  ERROR = "error"           // Fatal error occurred
}
```

### MockType
```typescript
enum MockType {
  MODULE = "module",        // jest.mock('module-name')
  FUNCTION = "function",    // jest.fn()
  SPY = "spy",              // jest.spyOn(object, 'method')
  PARTIAL = "partial"       // Mock some exports, keep others real
}
```

### HookType
```typescript
enum HookType {
  BEFORE_ALL = "beforeAll",    // Runs once before all tests in suite
  BEFORE_EACH = "beforeEach",  // Runs before each test
  AFTER_EACH = "afterEach",    // Runs after each test
  AFTER_ALL = "afterAll"       // Runs once after all tests in suite
}
```

### HookScope
```typescript
enum HookScope {
  SUITE = "suite",          // Applies to specific describe block
  GLOBAL = "global"         // Applies to all tests in file
}
```

---

## Relationships

### Test Suite → Test Case (One-to-Many)
- A test suite contains 1 to N test cases
- A test case belongs to exactly one suite
- Cascade: Deleting suite deletes all test cases (not applicable - runtime only)

### Test Suite → Test Hook (One-to-Many)
- A test suite can have 0 to N hooks
- Hooks are scoped to their suite
- beforeAll/afterAll run once per suite
- beforeEach/afterEach run N times (one per test case)

### Test Case → Assertion (One-to-Many)
- A test case contains 1 to N assertions
- An assertion belongs to exactly one test case
- Test fails if any assertion fails

### Test Runner → Test Suite (One-to-Many)
- Test runner discovers and executes N test suites
- Suites are executed in parallel (Jest default)
- Watch mode re-runs only affected suites (dependency graph)

### Mock → Test Case (Many-to-Many)
- A mock can be used by multiple test cases
- A test case can use multiple mocks
- Mocks are isolated per test (mockClear in beforeEach)

### Coverage Report → Test Runner (One-to-One)
- Coverage report is generated by one test run
- Test run in coverage mode produces one report
- Report aggregates data from all executed test suites

---

## State Transitions

### Test Case Lifecycle
```
[Created] → PENDING → RUNNING → PASSED
                               → FAILED
                               → SKIPPED

Special cases:
- .skip() → SKIPPED (never runs)
- .todo() → TODO (placeholder, never runs)
```

### Test Suite Lifecycle
```
[Created] → PENDING → RUNNING → PASSED (all tests passed)
                               → FAILED (≥1 test failed)
                               → SKIPPED (all tests skipped)
```

### Test Runner Lifecycle
```
[Created] → IDLE → DISCOVERING → RUNNING → COMPLETED
                                          → ERROR

Watch mode loop:
COMPLETED → [file change detected] → RUNNING → COMPLETED
```

---

## Data Flow

### Single Run Mode (npm test)
1. **Discovery**: Runner scans for `**/*.test.{ts,tsx}` files
2. **Load**: Import test suites (run describe blocks)
3. **Schedule**: Build execution plan (parallel workers)
4. **Execute**: Run tests (beforeAll → beforeEach → test → afterEach → afterAll)
5. **Report**: Aggregate results, print summary
6. **Exit**: Process terminates with exit code (0 = pass, 1 = fail)

### Watch Mode (npm run test:watch)
1. **Initial Run**: Same as single run
2. **Watch**: Monitor file system for changes
3. **Detect Change**: File modified
4. **Filter**: Determine affected tests (dependency graph)
5. **Re-run**: Execute only affected tests
6. **Report**: Print results (interactive menu remains open)
7. **Loop**: Return to step 2 (watch continues)

### Coverage Mode (npm run test:coverage)
1. **Instrument**: Add coverage tracking to source files
2. **Execute**: Run tests (same as single run)
3. **Collect**: Gather execution data from instrumented code
4. **Aggregate**: Calculate coverage metrics per file and overall
5. **Report**: Generate HTML/LCOV/JSON reports
6. **Exit**: Process terminates (coverage/ folder written)

---

## Constraints & Invariants

### Performance Constraints
- Test suite execution ≤ 10 seconds for 50 tests (SC-005)
- Watch mode re-run ≤ 2 seconds (SC-006)
- Individual test ≤ 200ms (target for fast feedback)

### Isolation Constraints
- Each test case must be independent (FR-013)
- Mocks must be cleared between tests (FR-013)
- No shared mutable state between tests (FR-013)

### Coverage Constraints
- Coverage metrics must be accurate (SC-007)
- Must track 4 metrics: statements, branches, functions, lines (FR-007)
- Must identify uncovered lines (FR-008)

### Naming Constraints
- Test files must match `**/*.test.{ts,tsx}` (FR-001)
- Test names must be descriptive (SC-004)
- Suite names must be unique within file (Jest enforces)

---

## Non-Functional Attributes

### Observability
- Test results printed to console (FR-003)
- Coverage reports saved to `coverage/` (FR-007)
- Watch mode shows affected file list (FR-011)
- Error stack traces include file:line (FR-003)

### Extensibility
- Custom matchers can be added (jest.extend)
- Reporters can be customized (jest.config.js)
- Transformers can be chained (TypeScript, CSS, images)

### Compatibility
- Cross-platform (Windows, macOS, Linux) (FR-020)
- Works with Next.js 14 App Router (FR-004)
- TypeScript 5.x support (FR-018)

---

## Example: Complete Test Execution State

```typescript
{
  runner: {
    mode: "watch",
    status: "completed",
    totalSuites: 8,
    executedSuites: 2, // Only re-ran affected tests
    startTime: new Date("2025-11-13T10:30:00Z"),
    endTime: new Date("2025-11-13T10:30:01.456Z"),
    config: jestConfigObject,
    watchedFiles: ["src/**/*.{ts,tsx}"],
    changedFiles: ["src/components/Navigation.tsx"]
  },
  suites: [
    {
      name: "Navigation Component",
      filePath: "/src/components/__tests__/Navigation.test.tsx",
      status: "passed",
      duration: 247,
      testCases: [
        {
          id: "test-001",
          name: "renders all navigation links",
          status: "passed",
          duration: 43,
          assertions: [
            { type: "toBeInTheDocument", expected: true, actual: true, passed: true }
          ]
        },
        {
          id: "test-002",
          name: "highlights active link",
          status: "passed",
          duration: 38,
          assertions: [
            { type: "toHaveClass", expected: "active", actual: "active", passed: true }
          ]
        }
      ],
      setupHooks: [
        { type: "beforeEach", implementation: jest.clearAllMocks }
      ]
    }
  ],
  coverage: null // Coverage not collected in watch mode
}
```

---

## Summary

This data model defines:
- **7 core entities**: Test Suite, Test Case, Test Runner, Coverage Report, Mock/Stub, Assertion, Test Hook
- **6 enumerations**: TestStatus, TestSuiteStatus, RunnerMode, RunnerStatus, MockType, HookType
- **Validation rules** tied to functional requirements (FR-001 to FR-020)
- **State transitions** for runtime execution
- **Performance constraints** from success criteria (SC-005 to SC-008)
- **Data flow** for single, watch, and coverage modes

The model is optimized for **runtime execution** (not persistence), emphasizing fast test execution, isolation, and developer feedback.
